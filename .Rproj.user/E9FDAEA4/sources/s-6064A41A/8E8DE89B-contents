#' Read and Write Items in QTI XML
#'
#' The qti_item class stores information on an assessment item. Methods
#' are available for modifying qti_item contents, and for reading and
#' writing to QTI XML files.
#'
#' @param x path to QTI XML file
#' @param \dots further arguments passed to or from other functions.
#' @return \code{read_qti} returns an object of class
#' \dQuote{\code{qti_item}}, which contains the following elements,
#' if present in x:
#' \item{id}{item id, extracted from the identifier attribute}
#' \item{title}{item title, extracted from the title attribute}
#' \item{type}{item type, currently \dQuote{\code{single}} for single choice}
#' \item{prompt}{text for the item stem}
#' \item{options}{list of text for options}
#' \item{key}{vector of correct/incorrect as 0/1 for options}
#' \item{xml}{raw XML contents, stored as an object of class
#' \dQuote{xml_document}}
#' @author Tony Albano \email{tony.d.albano@@gmail.com}
#'
#' @keywords methods
#' @examples
#'
#' item <- read_qti(
#'   "<assessmentItem identifier='1584'
#'     title='Excellent Example Item'>
#'     <responseDeclaration identifier='RESPONSE' cardinality='single'
#'       baseType='identifier'>
#'       <correctResponse>
#'         <value>ChoiceB</value>
#'       </correctResponse>
#'     </responseDeclaration>
#'     <outcomeDeclaration identifier='SCORE' cardinality='single'
#'       baseType='float'>
#'       <defaultValue><value>0</value></defaultValue>
#'     </outcomeDeclaration>
#'     <itemBody>
#'       <prompt>
#'         <p>Is this a really good question?</p>
#'       </prompt>
#'       <choiceInteraction responseIdentifier='RESPONSE' shuffle='false'
#'         maxChoices='1'>
#'         <simpleChoice identifier='ChoiceA'>Yes</simpleChoice>
#'         <simpleChoice identifier='ChoiceB'>No</simpleChoice>
#'         <simpleChoice identifier='ChoiceC'>Maybe</simpleChoice>
#'       </choiceInteraction>
#'     </itemBody>
#'   </assessmentItem>")
#' item
#'
#' @export
read_qti <- function(x, ...) {
  xml <- xml2::read_xml(x, ...)
  xml2::xml_ns_strip(xml)
  qti_clean_nodes(xml)
  out <- qti_item(id = qti_item_id(xml),
    title = qti_item_title(xml),
    type = qti_item_type(xml),
    prompt = qti_clean_text(qti_prompt_text(xml)),
    options = qti_clean_text(qti_choice_text(xml)),
    key = qti_key(xml),
    xml = xml2::read_xml(x, ...))
  return(out)
}

qti_item <- function(id = NULL, title = NULL, type = NULL, prompt = NULL,
  options = NULL, key = NULL, xml = NULL) {
  structure(list(id = id, title = title, type = type, prompt = prompt,
    options = options, key = key, xml = xml), class = "qti_item")
}

#' @export
print.qti_item <- function(x, ...) {
  cat("\nqti_item\n")
  cat(x$title, "\n")
  cat(x$id, "\n\n")
  cat(x$prompt, "\n\n")
  cat(paste(x$options, collapse = "\n\n"), "\n\n")
}

qti_clean_nodes <- function(x, xpaths = c("//image", "//img",
  "//math", "//pre", "//table"), xtext = gsub("(//)(.+)", " [\\2] ", xpaths)) {
  # Replace any text contents of image, img, math, pre, and table with
  # placeholders
  # Remove all children, which also removes closing tag
  # Remove all attributes
  # Set text to be placeholder in xtext, which adds closing tag
  # Modifying by reference
  for (i in seq_along(xpaths)) {
    temp_nodes <- xml2::xml_find_all(x, xpaths[i])
    if (length(temp_nodes)) {
      xml2::xml_remove(xml2::xml_children(temp_nodes))
      xml2::xml_attrs(temp_nodes) <- NULL
      xml2::xml_text(temp_nodes) <- xtext[i]
    }
    rm(temp_nodes) # Does gc do this for us?
  }
}

qti_prompt_text <- function(x, xpath = "//itemBody",
  rmpath = "//choiceInteraction") {
  # Extract prompt text, removing choice interactions
  # Copy the itemBody node (or full object for now), remove
  # choiceInteraction and children, pull remaining text
  y <- xml2::read_xml(as.character(x)) # What's the best way to copy?
  xml2::xml_remove(xml2::xml_find_all(y, rmpath), free = TRUE)
  xml2::xml_text(xml2::xml_find_all(y, xpath))
}

qti_choice_text <- function(x) {
  # Extract all choice text
  xml2::xml_text(xml2::xml_find_all(x, "//simpleChoice"))
}

qti_key <- function(x, xpath = "//correctResponse") {
  # Returns vector of 0/1 for keyed choices listed as values
  # under the correctResponse node
  key_id <- xml2::xml_text(xml2::xml_find_all(x, "//correctResponse//value"))
  choice_id <- unlist(lapply(xml2::xml_attrs(xml2::xml_find_all(x,
    "//simpleChoice")), "[[", "identifier"))
  return(ifelse(choice_id %in% key_id, 1, 0))
}

qti_item_id <- function(x) {
  xml2::xml_attr(xml2::xml_find_first(x, "//assessmentItem"), "identifier")
}

qti_item_title <- function(x) {
  xml2::xml_attr(xml2::xml_find_first(x, "//assessmentItem"), "title")
}

qti_item_type <- function(x) {
  item_type <- xml2::xml_attr(xml2::xml_find_first(x, "//outcomeDeclaration"),
    "cardinality")
  if (item_type %in% c("single", "multiple"))
    return("choice")
  else
    return(NULL)
}

qti_clean_text <- function(x) {
  # Remove newlines, leading option letters, and leading and trailing space
  rm <- "^\\s*\\w{1}\\.{1}"
  out <- sapply(x, function(y) gsub(rm, "", y))
  out <- sapply(out, function(y) gsub("\\s+", " ", y))
  out <- sapply(out, function(y) gsub("^[[:space:]]+|[[:space:]]+$", "", y))
  names(out) <- NULL
  return(out)
}

#' @describeIn qti_item
#' @export
qti_build <- function(x, template) {
  if (x$type == "choice") {
    if (missing(template))
      template <- system.file("templates", "choice.xml", package = "qti")
    #choice_template <- xml2::read_xml(template)
    choice_template <- xml2::read_xml("/users/talbano/documents/code/qti/inst/templates/choice.xml")
    n_ops <- length(unlist(x$options))
    choice_labels <- paste0("Choice", LETTERS[1:n_ops])
    xml2::xml_attr(choice_template, "identifier") <- x$id
    xml2::xml_attr(choice_template, "title") <- x$title
    # Add prompt
    # Canvas QTI requires HTML formatting, at least with <p>
    temp_prompt_node <- xml2::xml_find_first(choice_template, "//d1:prompt")
    new_prompt_node <- xml2::read_xml(paste0("<prompt>", x$prompt,
      "</prompt>"))
    xml2::xml_replace(temp_prompt_node, new_prompt_node)
    # Add simpleChoice children under choiceInteraction
    # Add value children under correctResponse for each key
    temp_interaction_node <- xml2::xml_find_first(choice_template,
      "//d1:choiceInteraction")
    temp_correct_node <- xml2::xml_find_first(choice_template,
      "//d1:correctResponse")
    for (o in 1:n_ops) {
      temp_choice_node <- xml2::read_xml(paste0("<simpleChoice>",
        x$options[o], "</simpleChoice>"))
      xml2::xml_attr(temp_choice_node, "identifier") <- choice_labels[o]
      xml2::xml_add_child(temp_interaction_node, temp_choice_node)
      if (x$key[o] == 1) {
        temp_value_node <- xml2::read_xml(paste0("<value>", choice_labels[o],
          "</value>"))
        xml2::xml_add_child(temp_correct_node, temp_value_node)
        rm(temp_value_node)
      }
    }
    rm(temp_choice_node, temp_interaction_node, temp_prompt_node)
    return(choice_template)
  }
  else
    return(NULL)
}

#' @describeIn qti_item
#' @export
write_qti <- function(x, file) {
  if (class(x) == "xml_document")
    xml2::write_xml(x, file)
  else if (class(x) == "qti_item") {
    if (is.null(x$xml))
      x$xml <- qti_build(x)
    xml2::write_xml(x$xml, file)
  } else
    stop("'x' must be class 'qti_item' or 'xml_document'")
}
